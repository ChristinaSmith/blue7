//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Tue Sep 18 11:53:53 EDT 2012
//
// Method conflict info:
// Method: in_put
// Conflict-free: out_get
// Conflicts: in_put
//
// Method: out_get
// Conflict-free: in_put
// Conflicts: out_get
//
//
// Ports:
// Name                         I/O  size props
// RDY_in_put                     O     1 reg
// out_get                        O    10
// RDY_out_get                    O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// in_put                         I    10
// EN_in_put                      I     1
// EN_out_get                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkSwap(CLK,
	      RST_N,

	      in_put,
	      EN_in_put,
	      RDY_in_put,

	      EN_out_get,
	      out_get,
	      RDY_out_get);
  input  CLK;
  input  RST_N;

  // action method in_put
  input  [9 : 0] in_put;
  input  EN_in_put;
  output RDY_in_put;

  // actionvalue method out_get
  input  EN_out_get;
  output [9 : 0] out_get;
  output RDY_out_get;

  // signals for module outputs
  wire [9 : 0] out_get;
  wire RDY_in_put, RDY_out_get;

  // register count
  reg [7 : 0] count;
  wire [7 : 0] count$D_IN;
  wire count$EN;

  // register flag
  reg flag;
  wire flag$D_IN, flag$EN;

  // register payloadOK
  reg payloadOK;
  wire payloadOK$D_IN, payloadOK$EN;

  // ports of submodule firstF
  wire [9 : 0] firstF$D_IN, firstF$D_OUT;
  wire firstF$CLR, firstF$DEQ, firstF$EMPTY_N, firstF$ENQ, firstF$FULL_N;

  // ports of submodule inF
  wire [9 : 0] inF$D_IN, inF$D_OUT;
  wire inF$CLR, inF$DEQ, inF$EMPTY_N, inF$ENQ, inF$FULL_N;

  // ports of submodule outF
  reg [9 : 0] outF$D_IN;
  wire [9 : 0] outF$D_OUT;
  wire outF$CLR, outF$DEQ, outF$EMPTY_N, outF$ENQ, outF$FULL_N;

  // ports of submodule secondF
  wire [9 : 0] secondF$D_IN, secondF$D_OUT;
  wire secondF$CLR, secondF$DEQ, secondF$EMPTY_N, secondF$ENQ, secondF$FULL_N;

  // ports of submodule thirdF
  wire [9 : 0] thirdF$D_IN, thirdF$D_OUT;
  wire thirdF$CLR, thirdF$DEQ, thirdF$EMPTY_N, thirdF$ENQ, thirdF$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_advance,
       CAN_FIRE_RL_advanceOutput,
       CAN_FIRE_RL_advanceOutputPayload,
       CAN_FIRE_RL_advanceOutputTwo,
       CAN_FIRE_in_put,
       CAN_FIRE_out_get,
       WILL_FIRE_RL_advance,
       WILL_FIRE_RL_advanceOutput,
       WILL_FIRE_RL_advanceOutputPayload,
       WILL_FIRE_RL_advanceOutputTwo,
       WILL_FIRE_in_put,
       WILL_FIRE_out_get;

  // inputs to muxes for submodule ports
  wire [9 : 0] MUX_outF$enq_1__VAL_1,
	       MUX_outF$enq_1__VAL_2,
	       MUX_outF$enq_1__VAL_3;
  wire MUX_flag$write_1__SEL_1;

  // remaining internal signals
  reg [1 : 0] CASE_firstFD_OUT_BITS_9_TO_8_3_0_firstFD_OUT_ETC__q3,
	      CASE_inFD_OUT_BITS_9_TO_8_3_0_inFD_OUT_BITS__ETC__q5,
	      CASE_in_put_BITS_9_TO_8_3_0_in_put_BITS_9_TO_8_ETC__q6,
	      CASE_outFD_OUT_BITS_9_TO_8_3_0_outFD_OUT_BIT_ETC__q1,
	      CASE_secondFD_OUT_BITS_9_TO_8_3_0_secondFD_O_ETC__q2,
	      CASE_thirdFD_OUT_BITS_9_TO_8_3_0_thirdFD_OUT_ETC__q4;
  wire count_1_ULT_12___d25, count_1_ULT_6___d14;

  // action method in_put
  assign RDY_in_put = inF$FULL_N ;
  assign CAN_FIRE_in_put = inF$FULL_N ;
  assign WILL_FIRE_in_put = EN_in_put ;

  // actionvalue method out_get
  assign out_get =
	     { CASE_outFD_OUT_BITS_9_TO_8_3_0_outFD_OUT_BIT_ETC__q1,
	       outF$D_OUT[7:0] } ;
  assign RDY_out_get = outF$EMPTY_N ;
  assign CAN_FIRE_out_get = outF$EMPTY_N ;
  assign WILL_FIRE_out_get = EN_out_get ;

  // submodule firstF
  SizedFIFO #(.p1width(32'd10),
	      .p2depth(32'd6),
	      .p3cntr_width(32'd3),
	      .guarded(32'd1)) firstF(.RST_N(RST_N),
				      .CLK(CLK),
				      .D_IN(firstF$D_IN),
				      .ENQ(firstF$ENQ),
				      .DEQ(firstF$DEQ),
				      .CLR(firstF$CLR),
				      .D_OUT(firstF$D_OUT),
				      .FULL_N(firstF$FULL_N),
				      .EMPTY_N(firstF$EMPTY_N));

  // submodule inF
  FIFO2 #(.width(32'd10), .guarded(32'd1)) inF(.RST_N(RST_N),
					       .CLK(CLK),
					       .D_IN(inF$D_IN),
					       .ENQ(inF$ENQ),
					       .DEQ(inF$DEQ),
					       .CLR(inF$CLR),
					       .D_OUT(inF$D_OUT),
					       .FULL_N(inF$FULL_N),
					       .EMPTY_N(inF$EMPTY_N));

  // submodule outF
  FIFO2 #(.width(32'd10), .guarded(32'd1)) outF(.RST_N(RST_N),
						.CLK(CLK),
						.D_IN(outF$D_IN),
						.ENQ(outF$ENQ),
						.DEQ(outF$DEQ),
						.CLR(outF$CLR),
						.D_OUT(outF$D_OUT),
						.FULL_N(outF$FULL_N),
						.EMPTY_N(outF$EMPTY_N));

  // submodule secondF
  SizedFIFO #(.p1width(32'd10),
	      .p2depth(32'd6),
	      .p3cntr_width(32'd3),
	      .guarded(32'd1)) secondF(.RST_N(RST_N),
				       .CLK(CLK),
				       .D_IN(secondF$D_IN),
				       .ENQ(secondF$ENQ),
				       .DEQ(secondF$DEQ),
				       .CLR(secondF$CLR),
				       .D_OUT(secondF$D_OUT),
				       .FULL_N(secondF$FULL_N),
				       .EMPTY_N(secondF$EMPTY_N));

  // submodule thirdF
  FIFO2 #(.width(32'd10), .guarded(32'd1)) thirdF(.RST_N(RST_N),
						  .CLK(CLK),
						  .D_IN(thirdF$D_IN),
						  .ENQ(thirdF$ENQ),
						  .DEQ(thirdF$DEQ),
						  .CLR(thirdF$CLR),
						  .D_OUT(thirdF$D_OUT),
						  .FULL_N(thirdF$FULL_N),
						  .EMPTY_N(thirdF$EMPTY_N));

  // rule RL_advanceOutput
  assign CAN_FIRE_RL_advanceOutput = outF$FULL_N && secondF$EMPTY_N ;
  assign WILL_FIRE_RL_advanceOutput = CAN_FIRE_RL_advanceOutput ;

  // rule RL_advanceOutputTwo
  assign CAN_FIRE_RL_advanceOutputTwo =
	     outF$FULL_N && firstF$EMPTY_N && !flag ;
  assign WILL_FIRE_RL_advanceOutputTwo =
	     CAN_FIRE_RL_advanceOutputTwo && !WILL_FIRE_RL_advanceOutput ;

  // rule RL_advanceOutputPayload
  assign CAN_FIRE_RL_advanceOutputPayload =
	     outF$FULL_N && thirdF$EMPTY_N && payloadOK ;
  assign WILL_FIRE_RL_advanceOutputPayload =
	     CAN_FIRE_RL_advanceOutputPayload &&
	     !WILL_FIRE_RL_advanceOutputTwo &&
	     !WILL_FIRE_RL_advanceOutput ;

  // rule RL_advance
  assign CAN_FIRE_RL_advance =
	     inF$EMPTY_N && firstF$FULL_N && secondF$FULL_N && thirdF$FULL_N ;
  assign WILL_FIRE_RL_advance = CAN_FIRE_RL_advance ;

  // inputs to muxes for submodule ports
  assign MUX_flag$write_1__SEL_1 =
	     WILL_FIRE_RL_advance && inF$D_OUT[9:8] != 2'd0 ;
  assign MUX_outF$enq_1__VAL_1 =
	     { CASE_secondFD_OUT_BITS_9_TO_8_3_0_secondFD_O_ETC__q2,
	       secondF$D_OUT[7:0] } ;
  assign MUX_outF$enq_1__VAL_2 =
	     { CASE_firstFD_OUT_BITS_9_TO_8_3_0_firstFD_OUT_ETC__q3,
	       firstF$D_OUT[7:0] } ;
  assign MUX_outF$enq_1__VAL_3 =
	     { CASE_thirdFD_OUT_BITS_9_TO_8_3_0_thirdFD_OUT_ETC__q4,
	       thirdF$D_OUT[7:0] } ;

  // register count
  assign count$D_IN = (inF$D_OUT[9:8] == 2'd0) ? count + 8'd1 : 8'd0 ;
  assign count$EN = CAN_FIRE_RL_advance ;

  // register flag
  assign flag$D_IN = MUX_flag$write_1__SEL_1 ;
  assign flag$EN =
	     WILL_FIRE_RL_advance && inF$D_OUT[9:8] != 2'd0 ||
	     WILL_FIRE_RL_advanceOutput ;

  // register payloadOK
  assign payloadOK$D_IN = !MUX_flag$write_1__SEL_1 ;
  assign payloadOK$EN =
	     WILL_FIRE_RL_advance && inF$D_OUT[9:8] != 2'd0 ||
	     WILL_FIRE_RL_advanceOutputTwo ;

  // submodule firstF
  assign firstF$D_IN =
	     { CASE_inFD_OUT_BITS_9_TO_8_3_0_inFD_OUT_BITS__ETC__q5,
	       inF$D_OUT[7:0] } ;
  assign firstF$ENQ = WILL_FIRE_RL_advance && count_1_ULT_6___d14 ;
  assign firstF$DEQ = WILL_FIRE_RL_advanceOutputTwo ;
  assign firstF$CLR = 1'b0 ;

  // submodule inF
  assign inF$D_IN =
	     { CASE_in_put_BITS_9_TO_8_3_0_in_put_BITS_9_TO_8_ETC__q6,
	       in_put[7:0] } ;
  assign inF$ENQ = EN_in_put ;
  assign inF$DEQ = CAN_FIRE_RL_advance ;
  assign inF$CLR = 1'b0 ;

  // submodule outF
  always@(WILL_FIRE_RL_advanceOutput or
	  MUX_outF$enq_1__VAL_1 or
	  WILL_FIRE_RL_advanceOutputTwo or
	  MUX_outF$enq_1__VAL_2 or
	  WILL_FIRE_RL_advanceOutputPayload or MUX_outF$enq_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_advanceOutput: outF$D_IN = MUX_outF$enq_1__VAL_1;
      WILL_FIRE_RL_advanceOutputTwo: outF$D_IN = MUX_outF$enq_1__VAL_2;
      WILL_FIRE_RL_advanceOutputPayload: outF$D_IN = MUX_outF$enq_1__VAL_3;
      default: outF$D_IN = 10'b1010101010 /* unspecified value */ ;
    endcase
  end
  assign outF$ENQ =
	     WILL_FIRE_RL_advanceOutput || WILL_FIRE_RL_advanceOutputTwo ||
	     WILL_FIRE_RL_advanceOutputPayload ;
  assign outF$DEQ = EN_out_get ;
  assign outF$CLR = 1'b0 ;

  // submodule secondF
  assign secondF$D_IN = firstF$D_IN ;
  assign secondF$ENQ =
	     WILL_FIRE_RL_advance && !count_1_ULT_6___d14 &&
	     count_1_ULT_12___d25 ;
  assign secondF$DEQ = CAN_FIRE_RL_advanceOutput ;
  assign secondF$CLR = 1'b0 ;

  // submodule thirdF
  assign thirdF$D_IN = firstF$D_IN ;
  assign thirdF$ENQ =
	     WILL_FIRE_RL_advance && !count_1_ULT_6___d14 &&
	     !count_1_ULT_12___d25 ;
  assign thirdF$DEQ = WILL_FIRE_RL_advanceOutputPayload ;
  assign thirdF$CLR = 1'b0 ;

  // remaining internal signals
  assign count_1_ULT_12___d25 = count < 8'd12 ;
  assign count_1_ULT_6___d14 = count < 8'd6 ;
  always@(outF$D_OUT)
  begin
    case (outF$D_OUT[9:8])
      2'd0, 2'd1, 2'd2:
	  CASE_outFD_OUT_BITS_9_TO_8_3_0_outFD_OUT_BIT_ETC__q1 =
	      outF$D_OUT[9:8];
      2'd3: CASE_outFD_OUT_BITS_9_TO_8_3_0_outFD_OUT_BIT_ETC__q1 = 2'd3;
    endcase
  end
  always@(secondF$D_OUT)
  begin
    case (secondF$D_OUT[9:8])
      2'd0, 2'd1, 2'd2:
	  CASE_secondFD_OUT_BITS_9_TO_8_3_0_secondFD_O_ETC__q2 =
	      secondF$D_OUT[9:8];
      2'd3: CASE_secondFD_OUT_BITS_9_TO_8_3_0_secondFD_O_ETC__q2 = 2'd3;
    endcase
  end
  always@(firstF$D_OUT)
  begin
    case (firstF$D_OUT[9:8])
      2'd0, 2'd1, 2'd2:
	  CASE_firstFD_OUT_BITS_9_TO_8_3_0_firstFD_OUT_ETC__q3 =
	      firstF$D_OUT[9:8];
      2'd3: CASE_firstFD_OUT_BITS_9_TO_8_3_0_firstFD_OUT_ETC__q3 = 2'd3;
    endcase
  end
  always@(thirdF$D_OUT)
  begin
    case (thirdF$D_OUT[9:8])
      2'd0, 2'd1, 2'd2:
	  CASE_thirdFD_OUT_BITS_9_TO_8_3_0_thirdFD_OUT_ETC__q4 =
	      thirdF$D_OUT[9:8];
      2'd3: CASE_thirdFD_OUT_BITS_9_TO_8_3_0_thirdFD_OUT_ETC__q4 = 2'd3;
    endcase
  end
  always@(inF$D_OUT)
  begin
    case (inF$D_OUT[9:8])
      2'd0, 2'd1, 2'd2:
	  CASE_inFD_OUT_BITS_9_TO_8_3_0_inFD_OUT_BITS__ETC__q5 =
	      inF$D_OUT[9:8];
      2'd3: CASE_inFD_OUT_BITS_9_TO_8_3_0_inFD_OUT_BITS__ETC__q5 = 2'd3;
    endcase
  end
  always@(in_put)
  begin
    case (in_put[9:8])
      2'd0, 2'd1, 2'd2:
	  CASE_in_put_BITS_9_TO_8_3_0_in_put_BITS_9_TO_8_ETC__q6 =
	      in_put[9:8];
      2'd3: CASE_in_put_BITS_9_TO_8_3_0_in_put_BITS_9_TO_8_ETC__q6 = 2'd3;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        count <= `BSV_ASSIGNMENT_DELAY 8'd0;
	flag <= `BSV_ASSIGNMENT_DELAY 1'd1;
	payloadOK <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (count$EN) count <= `BSV_ASSIGNMENT_DELAY count$D_IN;
	if (flag$EN) flag <= `BSV_ASSIGNMENT_DELAY flag$D_IN;
	if (payloadOK$EN) payloadOK <= `BSV_ASSIGNMENT_DELAY payloadOK$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    count = 8'hAA;
    flag = 1'h0;
    payloadOK = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkSwap

